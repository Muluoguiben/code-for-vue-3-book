**从范式上来看, 视图层框架通常分为命令式与声明式.**

#### 1.1 命令式 && 声明式

早年流下的jQuery就是典型的命令式框架. 命令式框架的一大特点就是**关注过程**.

```js
- 获取 id 为 app 的 div 标签
- 它的文本内容为 hello world
- 为其绑定点击事件
- 当点击时弹出提示： ok

对应的代码为 

	$('#app') // 获取div
		.text('hello world') // 设置文本内容
		.on('click', () => { alert('ok') }) // 绑定点击事件
```

等同于原生JS实现方式:

```js
const div = document.querySelector('#app')
div.innerText = 'hello world'
div.addEventListener('click', () => {alert('ok')})
```



与命令式框架更加注重过程不同, 声明式框架更加**关注结果**. Vue.js实现方式:

```vue
<div @click="() => alert('ok')"> hello world </div>
```

可以看到, 我们提供的是一个"结果", 至于如何实现这个"结果", 我们并不关心.

这就像我们告诉 Vue.js, ”嘿, Vue.js, 看到没, 我要的就是一个 div, 文本内容是 hello world, 它有个事件绑定, 你帮我搞定吧“

**至于实现"结果"的 过程, 则是由 Vue.js 帮我们完成的. 换句话说, Vue.js 帮我们封装了过程. 因此, 我们能够猜到 Vue.js 的内部一定是命令式的, 而暴露给用户的却更加声明式.**



#### 1.2 (两者间)性能与可维护性的权衡

结论: **声明式代码的性能不优于命令式代码的性能**

如果我们把直接修改的性能消耗定义为 A, 把找出差异的性能消耗定义为B, 那么有: 

- 命令式代码的更新性能消耗 = A
- 声明式代码的更新性能消耗 = B + A

声明式代码会比命令时代码多出找出差异的性能消耗, 因此最理想的情况是, 当找出差异的性能消耗为 0时, 声明式代码与命令式代码的性能**相同**, 但是无法做到超越. 毕竟**框架本身就是封装了命令式代码才实现了面向用户的声明式**



为什么Vue.js要选择声明式的设计方案呢? 

**原因在于声明式代码的可维护性更强**

采用命令式代码开发的时候, 我们需要维护实现目标的整个**过程,** 包括要手动完成 DOM 元素的创建, 更新, 删除等工作

而声明式代码展示的就是我们要的**结果**



在采用声明式提升可维护性的同时, 性能就会有一定的损失, 而框架设计者要做的是: **在保持可维护性的同时让性能损失最小化**



#### 1.3 虚拟DOM的性能到底如何

**声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**

因此, 如果我们能够最小化找出差异的性能优化, 就可以让声明式代码的性能**无限接近**命令时代码的性能. **而所谓的虚拟DOM, 就是为了最小化找出差异这一步的性能消耗而出现的**.



结论:  **虚拟DOM的意义旧在于使找出差异的性能消耗最小化**

![image-20220310202722567](https://first-1303075678.cos.ap-beijing.myqcloud.com/img/202203110126836.png)



<img src="https://first-1303075678.cos.ap-beijing.myqcloud.com/img/202203110126733.png" alt="image-20220310202819087"  />



通过 InnerHTML **创建**页面的性能: **HTML字符串拼接的计算量 + innerHTML 的 DOM 计算量**

通过虚拟 DOM 创建页面的性能: **创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量**

```js
const html = `
<div><span>...</span></div>
`

div.innerHTML = html
```

使用 innerHTML **更新**页面的过程的性能消耗: **重新构建HTML字符串, 再重新设置 DOM 元素的 innerHTML 元素**

**而重新设置innerHTML 属性就等价于销毁所有旧的DOM元素, 再全部创建新的DOM元素**

使用虚拟 DOM **更新**页面的过程的性能消耗: **重新创建 JavaScript 对象(虚拟DOM树), 比较新旧虚拟DOM, 找到变化的元素并更新**



用原生 JavaScript 操作 DOM 的方法 (如document.createElement) 、 虚拟DOM 和 innerHTML 三者操作页面的性能, 不可以简单地下定论, 这与 **页面大小, 变更部分的大小**都有关系, 除此之外, 与**创建页面还是更新页面**也有关系, 选择哪种更新策略, 需要我们结合**心智负担(操作难度)、可维护性等因素**综合考虑. 一番**权衡**之后, 发现虚拟 DOM 是个还不错的选择.



#### 1.4 运行时 && 编译时

结论: Vue.js 3 保持 运行时 + 编译时的架构 它在保持灵活性的基础上, 还能够通过编译手段分析用户提供的内容, 从而进一步提升更新性能.